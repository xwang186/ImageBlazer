{"version":3,"sources":["../../../../../src/mss/parser/MssParser.js"],"names":[],"mappings":"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","file":"MssParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @module MssParser\n * @param {Object} config object\n */\nfunction MssParser(config) {\n    config = config || {};\n    const BASE64 = config.BASE64;\n    const debug = config.debug;\n    const constants = config.constants;\n    const manifestModel = config.manifestModel;\n\n    const DEFAULT_TIME_SCALE = 10000000.0;\n    const SUPPORTED_CODECS = ['AAC', 'AACL', 'AVC1', 'H264', 'TTML', 'DFXP'];\n    // MPEG-DASH Role and accessibility mapping according to ETSI TS 103 285 v1.1.1 (section 7.1.2)\n    const ROLE = {\n        'SUBT': 'alternate',\n        'CAPT': 'alternate', // 'CAPT' is commonly equivalent to 'SUBT'\n        'DESC': 'main'\n    };\n    const ACCESSIBILITY = {\n        'DESC': '2'\n    };\n    const samplingFrequencyIndex = {\n        96000: 0x0,\n        88200: 0x1,\n        64000: 0x2,\n        48000: 0x3,\n        44100: 0x4,\n        32000: 0x5,\n        24000: 0x6,\n        22050: 0x7,\n        16000: 0x8,\n        12000: 0x9,\n        11025: 0xA,\n        8000: 0xB,\n        7350: 0xC\n    };\n    const mimeTypeMap = {\n        'video': 'video/mp4',\n        'audio': 'audio/mp4',\n        'text': 'application/mp4'\n    };\n\n    let instance,\n        logger,\n        mediaPlayerModel;\n\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    function mapPeriod(smoothStreamingMedia, timescale) {\n        const period = {};\n        let streams,\n            adaptation;\n\n        // For each StreamIndex node, create an AdaptationSet element\n        period.AdaptationSet_asArray = [];\n        streams = smoothStreamingMedia.getElementsByTagName('StreamIndex');\n        for (let i = 0; i < streams.length; i++) {\n            adaptation = mapAdaptationSet(streams[i], timescale);\n            if (adaptation !== null) {\n                period.AdaptationSet_asArray.push(adaptation);\n            }\n        }\n\n        if (period.AdaptationSet_asArray.length > 0) {\n            period.AdaptationSet = (period.AdaptationSet_asArray.length > 1) ? period.AdaptationSet_asArray : period.AdaptationSet_asArray[0];\n        }\n\n        return period;\n    }\n\n    function mapAdaptationSet(streamIndex, timescale) {\n        const adaptationSet = {};\n        const representations = [];\n        let segmentTemplate;\n        let qualityLevels,\n            representation,\n            segments,\n            i;\n\n        adaptationSet.id = streamIndex.getAttribute('Name') ? streamIndex.getAttribute('Name') : streamIndex.getAttribute('Type');\n        adaptationSet.contentType = streamIndex.getAttribute('Type');\n        adaptationSet.lang = streamIndex.getAttribute('Language') || 'und';\n        adaptationSet.mimeType = mimeTypeMap[adaptationSet.contentType];\n        adaptationSet.subType = streamIndex.getAttribute('Subtype');\n        adaptationSet.maxWidth = streamIndex.getAttribute('MaxWidth');\n        adaptationSet.maxHeight = streamIndex.getAttribute('MaxHeight');\n\n        // Map subTypes to MPEG-DASH AdaptationSet role and accessibility (see ETSI TS 103 285 v1.1.1, section 7.1.2)\n        if (adaptationSet.subType) {\n            if (ROLE[adaptationSet.subType]) {\n                let role = {\n                    schemeIdUri: 'urn:mpeg:dash:role:2011',\n                    value: ROLE[adaptationSet.subType]\n                };\n                adaptationSet.Role = role;\n                adaptationSet.Role_asArray = [role];\n            }\n            if (ACCESSIBILITY[adaptationSet.subType]) {\n                let accessibility = {\n                    schemeIdUri: 'urn:tva:metadata:cs:AudioPurposeCS:2007',\n                    value: ACCESSIBILITY[adaptationSet.subType]\n                };\n                adaptationSet.Accessibility = accessibility;\n                adaptationSet.Accessibility_asArray = [accessibility];\n            }\n        }\n\n        // Create a SegmentTemplate with a SegmentTimeline\n        segmentTemplate = mapSegmentTemplate(streamIndex, timescale);\n\n        qualityLevels = streamIndex.getElementsByTagName('QualityLevel');\n        // For each QualityLevel node, create a Representation element\n        for (i = 0; i < qualityLevels.length; i++) {\n            // Propagate BaseURL and mimeType\n            qualityLevels[i].BaseURL = adaptationSet.BaseURL;\n            qualityLevels[i].mimeType = adaptationSet.mimeType;\n\n            // Set quality level id\n            qualityLevels[i].Id = adaptationSet.id + '_' + qualityLevels[i].getAttribute('Index');\n\n            // Map Representation to QualityLevel\n            representation = mapRepresentation(qualityLevels[i], streamIndex);\n\n            if (representation !== null) {\n                // Copy SegmentTemplate into Representation\n                representation.SegmentTemplate = segmentTemplate;\n\n                representations.push(representation);\n            }\n        }\n\n        if (representations.length === 0) {\n            return null;\n        }\n\n        adaptationSet.Representation = (representations.length > 1) ? representations : representations[0];\n        adaptationSet.Representation_asArray = representations;\n\n        // Set SegmentTemplate\n        adaptationSet.SegmentTemplate = segmentTemplate;\n\n        segments = segmentTemplate.SegmentTimeline.S_asArray;\n\n        return adaptationSet;\n    }\n\n    function mapRepresentation(qualityLevel, streamIndex) {\n        const representation = {};\n        const type = streamIndex.getAttribute('Type');\n        let fourCCValue = null;\n\n        representation.id = qualityLevel.Id;\n        representation.bandwidth = parseInt(qualityLevel.getAttribute('Bitrate'), 10);\n        representation.mimeType = qualityLevel.mimeType;\n        representation.width = parseInt(qualityLevel.getAttribute('MaxWidth'), 10);\n        representation.height = parseInt(qualityLevel.getAttribute('MaxHeight'), 10);\n\n        fourCCValue = qualityLevel.getAttribute('FourCC');\n\n        // If FourCC not defined at QualityLevel level, then get it from StreamIndex level\n        if (fourCCValue === null || fourCCValue === '') {\n            fourCCValue = streamIndex.getAttribute('FourCC');\n        }\n\n        // If still not defined (optionnal for audio stream, see https://msdn.microsoft.com/en-us/library/ff728116%28v=vs.95%29.aspx),\n        // then we consider the stream is an audio AAC stream\n        if (fourCCValue === null || fourCCValue === '') {\n            if (type === 'audio') {\n                fourCCValue = 'AAC';\n            } else if (type === 'video') {\n                logger.debug('FourCC is not defined whereas it is required for a QualityLevel element for a StreamIndex of type \"video\"');\n                return null;\n            }\n        }\n\n        // Check if codec is supported\n        if (SUPPORTED_CODECS.indexOf(fourCCValue.toUpperCase()) === -1) {\n            // Do not send warning\n            logger.warn('Codec not supported: ' + fourCCValue);\n            return null;\n        }\n\n        // Get codecs value according to FourCC field\n        if (fourCCValue === 'H264' || fourCCValue === 'AVC1') {\n            representation.codecs = getH264Codec(qualityLevel);\n        } else if (fourCCValue.indexOf('AAC') >= 0) {\n            representation.codecs = getAACCodec(qualityLevel, fourCCValue);\n            representation.audioSamplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10);\n            representation.audioChannels = parseInt(qualityLevel.getAttribute('Channels'), 10);\n        } else if (fourCCValue.indexOf('TTML') || fourCCValue.indexOf('DFXP')) {\n            representation.codecs = constants.STPP;\n        }\n\n        representation.codecPrivateData = '' + qualityLevel.getAttribute('CodecPrivateData');\n        representation.BaseURL = qualityLevel.BaseURL;\n\n        return representation;\n    }\n\n    function getH264Codec(qualityLevel) {\n        let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString();\n        let nalHeader,\n            avcoti;\n\n\n        // Extract from the CodecPrivateData field the hexadecimal representation of the following\n        // three bytes in the sequence parameter set NAL unit.\n        // => Find the SPS nal header\n        nalHeader = /00000001[0-9]7/.exec(codecPrivateData);\n        // => Find the 6 characters after the SPS nalHeader (if it exists)\n        avcoti = nalHeader && nalHeader[0] ? (codecPrivateData.substr(codecPrivateData.indexOf(nalHeader[0]) + 10, 6)) : undefined;\n\n        return 'avc1.' + avcoti;\n    }\n\n    function getAACCodec(qualityLevel, fourCCValue) {\n        const samplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10);\n        let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString();\n        let objectType = 0;\n        let codecPrivateDataHex,\n            arr16,\n            indexFreq,\n            extensionSamplingFrequencyIndex;\n\n        //chrome problem, in implicit AAC HE definition, so when AACH is detected in FourCC\n        //set objectType to 5 => strange, it should be 2\n        if (fourCCValue === 'AACH') {\n            objectType = 0x05;\n        }\n        //if codecPrivateData is empty, build it :\n        if (codecPrivateData === undefined || codecPrivateData === '') {\n            objectType = 0x02; //AAC Main Low Complexity => object Type = 2\n            indexFreq = samplingFrequencyIndex[samplingRate];\n            if (fourCCValue === 'AACH') {\n                // 4 bytes :     XXXXX         XXXX          XXXX             XXXX                  XXXXX      XXX   XXXXXXX\n                //           ' ObjectType' 'Freq Index' 'Channels value'   'Extens Sampl Freq'  'ObjectType'  'GAS' 'alignment = 0'\n                objectType = 0x05; // High Efficiency AAC Profile = object Type = 5 SBR\n                codecPrivateData = new Uint8Array(4);\n                extensionSamplingFrequencyIndex = samplingFrequencyIndex[samplingRate * 2]; // in HE AAC Extension Sampling frequence\n                // equals to SamplingRate*2\n                //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                codecPrivateData[1] = (indexFreq << 7) | (qualityLevel.Channels << 3) | (extensionSamplingFrequencyIndex >> 1);\n                codecPrivateData[2] = (extensionSamplingFrequencyIndex << 7) | (0x02 << 2); // origin object type equals to 2 => AAC Main Low Complexity\n                codecPrivateData[3] = 0x0; //alignment bits\n\n                arr16 = new Uint16Array(2);\n                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                arr16[1] = (codecPrivateData[2] << 8) + codecPrivateData[3];\n                //convert decimal to hex value\n                codecPrivateDataHex = arr16[0].toString(16);\n                codecPrivateDataHex = arr16[0].toString(16) + arr16[1].toString(16);\n\n            } else {\n                // 2 bytes :     XXXXX         XXXX          XXXX              XXX\n                //           ' ObjectType' 'Freq Index' 'Channels value'   'GAS = 000'\n                codecPrivateData = new Uint8Array(2);\n                //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                codecPrivateData[1] = (indexFreq << 7) | (parseInt(qualityLevel.getAttribute('Channels'), 10) << 3);\n                // put the 2 bytes in an 16 bits array\n                arr16 = new Uint16Array(1);\n                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                //convert decimal to hex value\n                codecPrivateDataHex = arr16[0].toString(16);\n            }\n\n            codecPrivateData = '' + codecPrivateDataHex;\n            codecPrivateData = codecPrivateData.toUpperCase();\n            qualityLevel.setAttribute('CodecPrivateData', codecPrivateData);\n        } else if (objectType === 0) {\n            objectType = (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3;\n        }\n\n        return 'mp4a.40.' + objectType;\n    }\n\n    function mapSegmentTemplate(streamIndex, timescale) {\n        const segmentTemplate = {};\n        let mediaUrl,\n            streamIndexTimeScale;\n\n        mediaUrl = streamIndex.getAttribute('Url').replace('{bitrate}', '$Bandwidth$');\n        mediaUrl = mediaUrl.replace('{start time}', '$Time$');\n\n        streamIndexTimeScale = streamIndex.getAttribute('TimeScale');\n        streamIndexTimeScale = streamIndexTimeScale ? parseFloat(streamIndexTimeScale) : timescale;\n\n        segmentTemplate.media = mediaUrl;\n        segmentTemplate.timescale = streamIndexTimeScale;\n\n        segmentTemplate.SegmentTimeline = mapSegmentTimeline(streamIndex, segmentTemplate.timescale);\n\n        return segmentTemplate;\n    }\n\n    function mapSegmentTimeline(streamIndex, timescale) {\n        const segmentTimeline = {};\n        const chunks = streamIndex.getElementsByTagName('c');\n        const segments = [];\n        let segment,\n            prevSegment,\n            tManifest,\n            i,j,r;\n        let duration = 0;\n\n        for (i = 0; i < chunks.length; i++) {\n            segment = {};\n\n            // Get time 't' attribute value\n            tManifest = chunks[i].getAttribute('t');\n\n            // => segment.tManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler)\n            // => segment.t = number value of timestamp (maybe rounded value, but only for 0.1 microsecond)\n            segment.tManifest = parseFloat(tManifest);\n            segment.t = parseFloat(tManifest);\n\n            // Get duration 'd' attribute value\n            segment.d = parseFloat(chunks[i].getAttribute('d'));\n\n            // If 't' not defined for first segment then t=0\n            if ((i === 0) && !segment.t) {\n                segment.t = 0;\n            }\n\n            if (i > 0) {\n                prevSegment = segments[segments.length - 1];\n                // Update previous segment duration if not defined\n                if (!prevSegment.d) {\n                    if (prevSegment.tManifest) {\n                        prevSegment.d = parseFloat(tManifest) - parseFloat(prevSegment.tManifest);\n                    } else {\n                        prevSegment.d = segment.t - prevSegment.t;\n                    }\n                    duration += prevSegment.d;\n                }\n                // Set segment absolute timestamp if not set in manifest\n                if (!segment.t) {\n                    if (prevSegment.tManifest) {\n                        segment.tManifest = parseFloat(prevSegment.tManifest) + prevSegment.d;\n                        segment.t = parseFloat(segment.tManifest);\n                    } else {\n                        segment.t = prevSegment.t + prevSegment.d;\n                    }\n                }\n            }\n\n            if (segment.d) {\n                duration += segment.d;\n            }\n\n            // Create new segment\n            segments.push(segment);\n\n            // Support for 'r' attribute (i.e. \"repeat\" as in MPEG-DASH)\n            r = parseFloat(chunks[i].getAttribute('r'));\n            if (r) {\n\n                for (j = 0; j < (r - 1); j++) {\n                    prevSegment = segments[segments.length - 1];\n                    segment = {};\n                    segment.t = prevSegment.t + prevSegment.d;\n                    segment.d = prevSegment.d;\n                    if (prevSegment.tManifest) {\n                        segment.tManifest  = parseFloat(prevSegment.tManifest) + prevSegment.d;\n                    }\n                    duration += segment.d;\n                    segments.push(segment);\n                }\n            }\n        }\n\n        segmentTimeline.S = segments;\n        segmentTimeline.S_asArray = segments;\n        segmentTimeline.duration = duration / timescale;\n\n        return segmentTimeline;\n    }\n\n    function getKIDFromProtectionHeader(protectionHeader) {\n        let prHeader,\n            wrmHeader,\n            xmlReader,\n            KID;\n\n        // Get PlayReady header as byte array (base64 decoded)\n        prHeader = BASE64.decodeArray(protectionHeader.firstChild.data);\n\n        // Get Right Management header (WRMHEADER) from PlayReady header\n        wrmHeader = getWRMHeaderFromPRHeader(prHeader);\n\n        // Convert from multi-byte to unicode\n        wrmHeader = new Uint16Array(wrmHeader.buffer);\n\n        // Convert to string\n        wrmHeader = String.fromCharCode.apply(null, wrmHeader);\n\n        // Parse <WRMHeader> to get KID field value\n        xmlReader = (new DOMParser()).parseFromString(wrmHeader, 'application/xml');\n        KID = xmlReader.querySelector('KID').textContent;\n\n        // Get KID (base64 decoded) as byte array\n        KID = BASE64.decodeArray(KID);\n\n        // Convert UUID from little-endian to big-endian\n        convertUuidEndianness(KID);\n\n        return KID;\n    }\n\n    function getWRMHeaderFromPRHeader(prHeader) {\n        let length,\n            recordCount,\n            recordType,\n            recordLength,\n            recordValue;\n        let i = 0;\n\n        // Parse PlayReady header\n\n        // Length - 32 bits (LE format)\n        length = (prHeader[i + 3] << 24) + (prHeader[i + 2] << 16) + (prHeader[i + 1] << 8) + prHeader[i];\n        i += 4;\n\n        // Record count - 16 bits (LE format)\n        recordCount = (prHeader[i + 1] << 8) + prHeader[i];\n        i += 2;\n\n        // Parse records\n        while (i < prHeader.length) {\n            // Record type - 16 bits (LE format)\n            recordType = (prHeader[i + 1] << 8) + prHeader[i];\n            i += 2;\n\n            // Check if Rights Management header (record type = 0x01)\n            if (recordType === 0x01) {\n\n                // Record length - 16 bits (LE format)\n                recordLength = (prHeader[i + 1] << 8) + prHeader[i];\n                i += 2;\n\n                // Record value => contains <WRMHEADER>\n                recordValue = new Uint8Array(recordLength);\n                recordValue.set(prHeader.subarray(i, i + recordLength));\n                return recordValue;\n            }\n        }\n\n        return null;\n    }\n\n    function convertUuidEndianness(uuid) {\n        swapBytes(uuid, 0, 3);\n        swapBytes(uuid, 1, 2);\n        swapBytes(uuid, 4, 5);\n        swapBytes(uuid, 6, 7);\n    }\n\n    function swapBytes(bytes, pos1, pos2) {\n        const temp = bytes[pos1];\n        bytes[pos1] = bytes[pos2];\n        bytes[pos2] = temp;\n    }\n\n\n    function createPRContentProtection(protectionHeader) {\n        let pro = {\n            __text: protectionHeader.firstChild.data,\n            __prefix: 'mspr'\n        };\n        return {\n            schemeIdUri: 'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95',\n            value: 'com.microsoft.playready',\n            pro: pro,\n            pro_asArray: pro\n        };\n    }\n\n    function createWidevineContentProtection(protectionHeader, KID) {\n        // Create Widevine CENC header (Protocol Buffer) with KID value\n        const wvCencHeader = new Uint8Array(2 + KID.length);\n        wvCencHeader[0] = 0x12;\n        wvCencHeader[1] = 0x10;\n        wvCencHeader.set(KID, 2);\n\n        // Create a pssh box\n        const length = 12 /* box length, type, version and flags */ + 16 /* SystemID */ + 4 /* data length */ + wvCencHeader.length;\n        let pssh = new Uint8Array(length);\n        let i = 0;\n\n        // Set box length value\n        pssh[i++] = (length & 0xFF000000) >> 24;\n        pssh[i++] = (length & 0x00FF0000) >> 16;\n        pssh[i++] = (length & 0x0000FF00) >> 8;\n        pssh[i++] = (length & 0x000000FF);\n\n        // Set type ('pssh'), version (0) and flags (0)\n        pssh.set([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00], i);\n        i += 8;\n\n        // Set SystemID ('edef8ba9-79d6-4ace-a3c8-27dcd51d21ed')\n        pssh.set([0xed, 0xef, 0x8b, 0xa9,  0x79, 0xd6, 0x4a, 0xce, 0xa3, 0xc8, 0x27, 0xdc, 0xd5, 0x1d, 0x21, 0xed], i);\n        i += 16;\n\n        // Set data length value\n        pssh[i++] = (wvCencHeader.length & 0xFF000000) >> 24;\n        pssh[i++] = (wvCencHeader.length & 0x00FF0000) >> 16;\n        pssh[i++] = (wvCencHeader.length & 0x0000FF00) >> 8;\n        pssh[i++] = (wvCencHeader.length & 0x000000FF);\n\n        // Copy Widevine CENC header\n        pssh.set(wvCencHeader, i);\n\n        // Convert to BASE64 string\n        pssh = String.fromCharCode.apply(null, pssh);\n        pssh = BASE64.encodeASCII(pssh);\n\n        return {\n            schemeIdUri: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed',\n            value: 'com.widevine.alpha',\n            pssh: {\n                __text: pssh\n            }\n        };\n    }\n\n    function processManifest(xmlDoc, manifestLoadedTime) {\n        const manifest = {};\n        const contentProtections = [];\n        const smoothStreamingMedia = xmlDoc.getElementsByTagName('SmoothStreamingMedia')[0];\n        const protection = xmlDoc.getElementsByTagName('Protection')[0];\n        let protectionHeader = null;\n        let period,\n            adaptations,\n            contentProtection,\n            KID,\n            timestampOffset,\n            startTime,\n            segments,\n            timescale,\n            i, j;\n\n        // Set manifest node properties\n        manifest.protocol = 'MSS';\n        manifest.profiles = 'urn:mpeg:dash:profile:isoff-live:2011';\n        manifest.type = smoothStreamingMedia.getAttribute('IsLive') === 'TRUE' ? 'dynamic' : 'static';\n        timescale =  smoothStreamingMedia.getAttribute('TimeScale');\n        manifest.timescale = timescale ? parseFloat(timescale) : DEFAULT_TIME_SCALE;\n        let dvrWindowLength = parseFloat(smoothStreamingMedia.getAttribute('DVRWindowLength'));\n        if (dvrWindowLength === 0 && smoothStreamingMedia.getAttribute('CanSeek') === 'TRUE') {\n            dvrWindowLength = Infinity;\n        }\n        if (dvrWindowLength > 0) {\n            manifest.timeShiftBufferDepth = dvrWindowLength / manifest.timescale;\n        }\n\n        let duration = parseFloat(smoothStreamingMedia.getAttribute('Duration'));\n        manifest.mediaPresentationDuration = (duration === 0) ? Infinity : duration / manifest.timescale;\n        manifest.minBufferTime = mediaPlayerModel.getStableBufferTime();\n        manifest.ttmlTimeIsRelative = true;\n\n        // Live manifest with Duration = start-over\n        if (manifest.type === 'dynamic' && duration > 0) {\n            manifest.type = 'static';\n            // We set timeShiftBufferDepth to initial duration, to be used by MssFragmentController to update segment timeline\n            manifest.timeShiftBufferDepth = duration / manifest.timescale;\n            // Duration will be set according to current segment timeline duration (see below)\n        }\n\n        // In case of live streams, set availabilityStartTime property according to DVRWindowLength\n        if (manifest.type === 'dynamic'  && manifest.timeShiftBufferDepth < Infinity) {\n            manifest.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (manifest.timeShiftBufferDepth * 1000));\n            manifest.refreshManifestOnSwitchTrack = true;\n            manifest.doNotUpdateDVRWindowOnBufferUpdated = true; // DVRWindow is update by MssFragmentMoofPocessor based on tfrf boxes\n            manifest.ignorePostponeTimePeriod = true; // Never update manifest\n        }\n\n        // Map period node to manifest root node\n        manifest.Period = mapPeriod(smoothStreamingMedia, manifest.timescale);\n        manifest.Period_asArray = [manifest.Period];\n\n        // Initialize period start time\n        period = manifest.Period;\n        period.start = 0;\n\n        // Uncomment to test live to static manifests\n        // if (manifest.type !== 'static') {\n        //     manifest.type = 'static';\n        //     manifest.mediaPresentationDuration = manifest.timeShiftBufferDepth;\n        //     manifest.timeShiftBufferDepth = null;\n        // }\n\n        // ContentProtection node\n        if (protection !== undefined) {\n            protectionHeader = xmlDoc.getElementsByTagName('ProtectionHeader')[0];\n\n            // Some packagers put newlines into the ProtectionHeader base64 string, which is not good\n            // because this cannot be correctly parsed. Let's just filter out any newlines found in there.\n            protectionHeader.firstChild.data = protectionHeader.firstChild.data.replace(/\\n|\\r/g, '');\n\n            // Get KID (in CENC format) from protection header\n            KID = getKIDFromProtectionHeader(protectionHeader);\n\n            // Create ContentProtection for PlayReady\n            contentProtection = createPRContentProtection(protectionHeader);\n            contentProtection['cenc:default_KID'] = KID;\n            contentProtections.push(contentProtection);\n\n            // Create ContentProtection for Widevine (as a CENC protection)\n            contentProtection = createWidevineContentProtection(protectionHeader, KID);\n            contentProtection['cenc:default_KID'] = KID;\n            contentProtections.push(contentProtection);\n\n            manifest.ContentProtection = contentProtections;\n            manifest.ContentProtection_asArray = contentProtections;\n        }\n\n        adaptations = period.AdaptationSet_asArray;\n\n        for (i = 0; i < adaptations.length; i += 1) {\n            adaptations[i].SegmentTemplate.initialization = '$Bandwidth$';\n            // Propagate content protection information into each adaptation\n            if (manifest.ContentProtection !== undefined) {\n                adaptations[i].ContentProtection = manifest.ContentProtection;\n                adaptations[i].ContentProtection_asArray = manifest.ContentProtection_asArray;\n            }\n\n            if (manifest.type === 'dynamic') {\n                // Set availabilityStartTime for infinite DVR Window from segment timeline duration\n                if (manifest.timeShiftBufferDepth === Infinity) {\n                    manifest.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (adaptations[i].SegmentTemplate.SegmentTimeline.duration * 1000));\n                }\n                // Match timeShiftBufferDepth to video segment timeline duration\n                if (manifest.timeShiftBufferDepth > 0 &&\n                    manifest.timeShiftBufferDepth !== Infinity &&\n                    adaptations[i].contentType === 'video' &&\n                    manifest.timeShiftBufferDepth > adaptations[i].SegmentTemplate.SegmentTimeline.duration) {\n                    manifest.timeShiftBufferDepth = adaptations[i].SegmentTemplate.SegmentTimeline.duration;\n                }\n            }\n        }\n\n        if (manifest.timeShiftBufferDepth < manifest.minBufferTime) {\n            manifest.minBufferTime = manifest.timeShiftBufferDepth;\n        }\n\n        // Delete Content Protection under root manifest node\n        delete manifest.ContentProtection;\n        delete manifest.ContentProtection_asArray;\n\n        // In case of VOD streams, check if start time is greater than 0\n        // Then determine timestamp offset according to higher audio/video start time\n        // (use case = live stream delinearization)\n        if (manifest.type === 'static') {\n            // In case of start-over stream and manifest reloading (due to track switch)\n            // we consider previous timestampOffset to keep timelines synchronized\n            var prevManifest = manifestModel.getValue();\n            if (prevManifest && prevManifest.timestampOffset) {\n                timestampOffset = prevManifest.timestampOffset;\n            } else {\n                for (i = 0; i < adaptations.length; i++) {\n                    if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                        segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                        startTime = segments[0].t / adaptations[i].SegmentTemplate.timescale;\n                        if (timestampOffset === undefined) {\n                            timestampOffset = startTime;\n                        }\n                        timestampOffset = Math.min(timestampOffset, startTime);\n                        // Correct content duration according to minimum adaptation's segment timeline duration\n                        // in order to force <video> element sending 'ended' event\n                        manifest.mediaPresentationDuration = Math.min(manifest.mediaPresentationDuration, adaptations[i].SegmentTemplate.SegmentTimeline.duration);\n                    }\n                }\n            }\n            // Patch segment templates timestamps and determine period start time (since audio/video should not be aligned to 0)\n            if (timestampOffset > 0) {\n                manifest.timestampOffset = timestampOffset;\n                for (i = 0; i < adaptations.length; i++) {\n                    segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                    for (j = 0; j < segments.length; j++) {\n                        if (!segments[j].tManifest) {\n                            segments[j].tManifest = segments[j].t;\n                        }\n                        segments[j].t -= (timestampOffset * adaptations[i].SegmentTemplate.timescale);\n                    }\n                    if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                        period.start = Math.max(segments[0].t, period.start);\n                        adaptations[i].SegmentTemplate.presentationTimeOffset = period.start;\n                    }\n                }\n                period.start /= manifest.timescale;\n            }\n        }\n\n        // Floor the duration to get around precision differences between segments timestamps and MSE buffer timestamps\n        // and the avoid 'ended' event not being raised\n        manifest.mediaPresentationDuration = Math.floor(manifest.mediaPresentationDuration * 1000) / 1000;\n        period.duration = manifest.mediaPresentationDuration;\n\n        return manifest;\n    }\n\n    function parseDOM(data) {\n        let xmlDoc = null;\n\n        if (window.DOMParser) {\n            const parser = new window.DOMParser();\n\n            xmlDoc = parser.parseFromString(data, 'text/xml');\n            if (xmlDoc.getElementsByTagName('parsererror').length > 0) {\n                throw new Error('parsing the manifest failed');\n            }\n        }\n\n        return xmlDoc;\n    }\n\n    function getMatchers() {\n        return null;\n    }\n\n    function getIron() {\n        return null;\n    }\n\n    function internalParse(data) {\n        let xmlDoc = null;\n        let manifest = null;\n\n        const startTime = window.performance.now();\n\n        // Parse the MSS XML manifest\n        xmlDoc = parseDOM(data);\n\n        const xmlParseTime = window.performance.now();\n\n        if (xmlDoc === null) {\n            return null;\n        }\n\n        // Convert MSS manifest into DASH manifest\n        manifest = processManifest(xmlDoc, new Date());\n\n        const mss2dashTime = window.performance.now();\n\n        logger.info('Parsing complete: (xmlParsing: ' + (xmlParseTime - startTime).toPrecision(3) + 'ms, mss2dash: ' + (mss2dashTime - xmlParseTime).toPrecision(3) + 'ms, total: ' + ((mss2dashTime - startTime) / 1000).toPrecision(3) + 's)');\n\n        return manifest;\n    }\n\n    instance = {\n        parse: internalParse,\n        getMatchers: getMatchers,\n        getIron: getIron\n    };\n\n    setup();\n\n    return instance;\n}\n\nMssParser.__dashjs_factory_name = 'MssParser';\nexport default dashjs.FactoryMaker.getClassFactory(MssParser); /* jshint ignore:line */\n"]}