{"version":3,"sources":["../../../../../src/streaming/text/TextSourceBuffer.js"],"names":[],"mappings":"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","file":"TextSourceBuffer.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport {HTTPRequest} from '../vo/metrics/HTTPRequest';\nimport TextTrackInfo from '../vo/TextTrackInfo';\nimport BoxParser from '../utils/BoxParser';\nimport CustomTimeRanges from '../utils/CustomTimeRanges';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport TextTracks from './TextTracks';\nimport EmbeddedTextHtmlRender from './EmbeddedTextHtmlRender';\nimport ISOBoxer from 'codem-isoboxer';\nimport cea608parser from '../../../externals/cea608-parser';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport DashJSError from '../vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nfunction TextSourceBuffer() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    let embeddedInitialized = false;\n\n    let instance,\n        logger,\n        boxParser,\n        errHandler,\n        dashManifestModel,\n        manifestModel,\n        mediaController,\n        parser,\n        vttParser,\n        ttmlParser,\n        mediaInfos,\n        textTracks,\n        fragmentedFragmentModel,\n        initializationSegmentReceived,\n        timescale,\n        fragmentedTracks,\n        videoModel,\n        streamController,\n        firstFragmentedSubtitleStart,\n        currFragmentedTrackIdx,\n        embeddedTracks,\n        embeddedInitializationSegmentReceived,\n        embeddedTimescale,\n        embeddedLastSequenceNumber,\n        embeddedSequenceNumbers,\n        embeddedCea608FieldParsers,\n        embeddedTextHtmlRender,\n        mseTimeOffset;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        resetInitialSettings();\n    }\n\n    function resetFragmented () {\n        fragmentedFragmentModel = null;\n        timescale = NaN;\n        fragmentedTracks = [];\n        firstFragmentedSubtitleStart = null;\n        initializationSegmentReceived = false;\n    }\n\n    function resetInitialSettings() {\n        resetFragmented();\n\n        mediaInfos = [];\n        parser = null;\n    }\n\n    function initialize(mimeType, streamProcessor) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n\n        if (!boxParser) {\n            boxParser = BoxParser(context).getInstance();\n        }\n\n        addMediaInfos(mimeType, streamProcessor);\n    }\n\n    function addMediaInfos(mimeType, streamProcessor) {\n        const isFragmented = !dashManifestModel.getIsTextTrack(mimeType);\n        if (streamProcessor) {\n            mediaInfos = mediaInfos.concat(streamProcessor.getMediaInfoArr());\n\n            if (isFragmented) {\n                fragmentedFragmentModel = streamProcessor.getFragmentModel();\n                instance.buffered = CustomTimeRanges(context).create();\n                fragmentedTracks = mediaController.getTracksFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n                const currFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n                for (let i = 0; i < fragmentedTracks.length; i++) {\n                    if (fragmentedTracks[i] === currFragTrack) {\n                        setCurrentFragmentedTrackIdx(i);\n                        break;\n                    }\n                }\n            }\n\n            for (let i = 0; i < mediaInfos.length; i++) {\n                createTextTrackFromMediaInfo(null, mediaInfos[i]);\n            }\n        }\n    }\n\n    function abort() {\n        textTracks.deleteAllTextTracks();\n        boxParser = null;\n        mediaInfos = [];\n        fragmentedFragmentModel = null;\n        initializationSegmentReceived = false;\n        fragmentedTracks = [];\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        streamController = null;\n        videoModel = null;\n        textTracks = null;\n    }\n\n    function onVideoChunkReceived(e) {\n        const chunk = e.chunk;\n\n        if (chunk.mediaInfo.embeddedCaptions) {\n            append(chunk.bytes, chunk);\n        }\n    }\n\n    function initEmbedded() {\n        embeddedTracks = [];\n        textTracks = TextTracks(context).getInstance();\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n        boxParser = BoxParser(context).getInstance();\n        currFragmentedTrackIdx = null;\n        embeddedInitializationSegmentReceived = false;\n        embeddedTimescale = 0;\n        embeddedCea608FieldParsers = [];\n        embeddedSequenceNumbers = [];\n        embeddedLastSequenceNumber = null;\n        embeddedInitialized = true;\n        embeddedTextHtmlRender = EmbeddedTextHtmlRender(context).getInstance();\n\n        const streamProcessors = streamController.getActiveStreamProcessors();\n        for (const i in streamProcessors) {\n            if (streamProcessors[i].getType() === 'video') {\n                mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset;\n                break;\n            }\n        }\n\n        eventBus.on(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n    }\n\n    function resetEmbedded() {\n        eventBus.off(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        if (textTracks) {\n            textTracks.deleteAllTextTracks();\n        }\n        embeddedInitialized = false;\n        embeddedTracks = [];\n        embeddedCea608FieldParsers = [null, null];\n        embeddedSequenceNumbers = [];\n        embeddedLastSequenceNumber = null;\n    }\n\n    function addEmbeddedTrack(mediaInfo) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n        if (mediaInfo) {\n            if (mediaInfo.id === Constants.CC1 || mediaInfo.id === Constants.CC3) {\n                for (let i = 0; i < embeddedTracks.length; i++) {\n                    if (embeddedTracks[i].id === mediaInfo.id) {\n                        return;\n                    }\n                }\n                embeddedTracks.push(mediaInfo);\n            } else {\n                logger.warn('Embedded track ' + mediaInfo.id + ' not supported!');\n            }\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.dashManifestModel) {\n            dashManifestModel = config.dashManifestModel;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.mediaController) {\n            mediaController = config.mediaController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.textTracks) {\n            textTracks = config.textTracks;\n        }\n        if (config.vttParser) {\n            vttParser = config.vttParser;\n        }\n        if (config.ttmlParser) {\n            ttmlParser = config.ttmlParser;\n        }\n    }\n\n    function getConfig() {\n        const config = {\n            fragmentModel: fragmentedFragmentModel,\n            fragmentedTracks: fragmentedTracks,\n            videoModel: videoModel\n        };\n\n        return config;\n    }\n\n    function setCurrentFragmentedTrackIdx(idx) {\n        currFragmentedTrackIdx = idx;\n    }\n\n    function createTextTrackFromMediaInfo(captionData, mediaInfo) {\n        const textTrackInfo = new TextTrackInfo();\n        const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n        const getKind = function () {\n            let kind = (mediaInfo.roles.length > 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n            kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption;\n            return kind;\n        };\n\n        const checkTTML = function () {\n            let ttml = false;\n            if (mediaInfo.codec && mediaInfo.codec.search(Constants.STPP) >= 0) {\n                ttml = true;\n            }\n            if (mediaInfo.mimeType && mediaInfo.mimeType.search(Constants.TTML) >= 0) {\n                ttml = true;\n            }\n            return ttml;\n        };\n\n        textTrackInfo.captionData = captionData;\n        textTrackInfo.lang = mediaInfo.lang;\n        textTrackInfo.labels = mediaInfo.labels;\n        textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index\n        textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest\n        textTrackInfo.isTTML = checkTTML();\n        textTrackInfo.defaultTrack = getIsDefault(mediaInfo);\n        textTrackInfo.isFragmented = !dashManifestModel.getIsTextTrack(mediaInfo.mimeType);\n        textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false;\n        textTrackInfo.kind = getKind();\n        textTrackInfo.roles = mediaInfo.roles;\n        textTrackInfo.accessibility = mediaInfo.accessibility;\n        const totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length;\n        textTracks.addTextTrack(textTrackInfo, totalNrTracks);\n    }\n\n    function append(bytes, chunk) {\n        let result,\n            sampleList,\n            i, j, k,\n            samplesInfo,\n            ccContent;\n        const mediaInfo = chunk.mediaInfo;\n        const mediaType = mediaInfo.type;\n        const mimeType = mediaInfo.mimeType;\n        const codecType = mediaInfo.codec || mimeType;\n        if (!codecType) {\n            logger.error('No text type defined');\n            return;\n        }\n\n        if (mediaType === Constants.FRAGMENTED_TEXT) {\n            if (!initializationSegmentReceived) {\n                initializationSegmentReceived = true;\n                timescale = boxParser.getMediaTimescaleFromMoov(bytes);\n            } else {\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n                sampleList = samplesInfo.sampleList;\n                if (firstFragmentedSubtitleStart === null && sampleList.length > 0) {\n                    firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale;\n                }\n                if (codecType.search(Constants.STPP) >= 0) {\n                    parser = parser !== null ? parser : getParser(codecType);\n                    for (i = 0; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        const sampleStart = sample.cts;\n                        const sampleRelStart = sampleStart - firstFragmentedSubtitleStart;\n                        this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale);\n                        const dataView = new DataView(bytes, sample.offset, sample.subSizes[0]);\n                        ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n                        const images = [];\n                        let subOffset = sample.offset + sample.subSizes[0];\n                        for (j = 1; j < sample.subSizes.length; j++) {\n                            const inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]);\n                            const raw = String.fromCharCode.apply(null, inData);\n                            images.push(raw);\n                            subOffset += sample.subSizes[j];\n                        }\n                        try {\n                            // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset.\n                            const manifest = manifestModel.getValue();\n                            const offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0;\n                            result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images);\n                            textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result);\n                        } catch (e) {\n                            fragmentedFragmentModel.removeExecutedRequestsBeforeTime();\n                            this.remove();\n                            logger.error('TTML parser error: ' + e.message);\n                        }\n                    }\n                } else {\n                    // WebVTT case\n                    const captionArray = [];\n                    for (i = 0 ; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        sample.cts -= firstFragmentedSubtitleStart;\n                        this.buffered.add(sample.cts / timescale, (sample.cts + sample.duration) / timescale);\n                        const sampleData = bytes.slice(sample.offset, sample.offset + sample.size);\n                        // There are boxes inside the sampleData, so we need a ISOBoxer to get at it.\n                        const sampleBoxes = ISOBoxer.parseBuffer(sampleData);\n\n                        for (j = 0 ; j < sampleBoxes.boxes.length; j++) {\n                            const box1 = sampleBoxes.boxes[j];\n                            logger.debug('VTT box1: ' + box1.type);\n                            if (box1.type === 'vtte') {\n                                continue; //Empty box\n                            }\n                            if (box1.type === 'vttc') {\n                                logger.debug('VTT vttc boxes.length = ' + box1.boxes.length);\n                                for (k = 0 ; k < box1.boxes.length; k++) {\n                                    const box2 = box1.boxes[k];\n                                    logger.debug('VTT box2: ' + box2.type);\n                                    if (box2.type === 'payl') {\n                                        const cue_text = box2.cue_text;\n                                        logger.debug('VTT cue_text = ' + cue_text);\n                                        const start_time = sample.cts / timescale;\n                                        const end_time = (sample.cts + sample.duration) / timescale;\n                                        captionArray.push({\n                                            start: start_time,\n                                            end: end_time,\n                                            data: cue_text,\n                                            styles: {}\n                                        });\n                                        logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (captionArray.length > 0) {\n                        textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray);\n                    }\n                }\n            }\n        } else if (mediaType === Constants.TEXT) {\n            const dataView = new DataView(bytes, 0, bytes.byteLength);\n            ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n\n            try {\n                result = getParser(codecType).parse(ccContent, 0);\n                textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result);\n            } catch (e) {\n                errHandler.timedTextError(e, 'parse', ccContent);\n                errHandler.error(new DashJSError(Errors.TIMED_TEXT_ERROR_ID_PARSE_CODE, Errors.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent));\n            }\n        } else if (mediaType === Constants.VIDEO) { //embedded text\n            if (chunk.segmentType === HTTPRequest.INIT_SEGMENT_TYPE) {\n                if (embeddedTimescale === 0) {\n                    embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes);\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        createTextTrackFromMediaInfo(null, embeddedTracks[i]);\n                    }\n                }\n            } else { // MediaSegment\n                if (embeddedTimescale === 0) {\n                    logger.warn('CEA-608: No timescale for embeddedTextTrack yet');\n                    return;\n                }\n                const makeCueAdderForIndex = function (self, trackIndex) {\n                    function newCue(startTime, endTime, captionScreen) {\n                        let captionsArray = null;\n                        if (videoModel.getTTMLRenderingDiv()) {\n                            captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen);\n                        } else {\n                            const text = captionScreen.getDisplayText();\n                            captionsArray = [{\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: {}\n                            }];\n                        }\n                        if (captionsArray) {\n                            textTracks.addCaptions(trackIndex, 0, captionsArray);\n                        }\n                    }\n                    return newCue;\n                };\n\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n\n                const sequenceNumber = samplesInfo.lastSequenceNumber;\n\n                if (!embeddedCea608FieldParsers[0] && !embeddedCea608FieldParsers[1]) {\n                    // Time to setup the CEA-608 parsing\n                    let field, handler, trackIdx;\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        if (embeddedTracks[i].id === Constants.CC1) {\n                            field = 0;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC1);\n                        } else if (embeddedTracks[i].id === Constants.CC3) {\n                            field = 1;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC3);\n                        }\n                        if (trackIdx === -1) {\n                            logger.warn('CEA-608: data before track is ready.');\n                            return;\n                        }\n                        handler = makeCueAdderForIndex(this, trackIdx);\n                        embeddedCea608FieldParsers[i] = new cea608parser.Cea608Parser(i + 1, {\n                            'newCue': handler\n                        }, null);\n                    }\n                }\n\n                if (embeddedTimescale && embeddedSequenceNumbers.indexOf(sequenceNumber) == -1) {\n                    if (embeddedLastSequenceNumber !== null && sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) {\n                        for (i = 0; i < embeddedCea608FieldParsers.length; i++) {\n                            if (embeddedCea608FieldParsers[i]) {\n                                embeddedCea608FieldParsers[i].reset();\n                            }\n                        }\n                    }\n\n                    const allCcData = extractCea608Data(bytes, samplesInfo.sampleList);\n\n                    for (let fieldNr = 0; fieldNr < embeddedCea608FieldParsers.length; fieldNr++) {\n                        const ccData = allCcData.fields[fieldNr];\n                        const fieldParser = embeddedCea608FieldParsers[fieldNr];\n                        if (fieldParser) {\n                            for (i = 0; i < ccData.length; i++) {\n                                fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]);\n                            }\n                        }\n                    }\n                    embeddedLastSequenceNumber = sequenceNumber;\n                    embeddedSequenceNumbers.push(sequenceNumber);\n                }\n            }\n        }\n    }\n    /**\n     * Extract CEA-608 data from a buffer of data.\n     * @param {ArrayBuffer} data\n     * @param {Array} samples cue information\n     * @returns {Object|null} ccData corresponding to one segment.\n     */\n    function extractCea608Data(data, samples) {\n        if (samples.length === 0) {\n            return null;\n        }\n\n        const allCcData = {\n            splits: [],\n            fields: [[], []]\n        };\n        const raw = new DataView(data);\n        for (let i = 0; i < samples.length; i++) {\n            const sample = samples[i];\n            const cea608Ranges = cea608parser.findCea608Nalus(raw, sample.offset, sample.size);\n            let lastSampleTime = null;\n            let idx = 0;\n            for (let j = 0; j < cea608Ranges.length; j++) {\n                const ccData = cea608parser.extractCea608DataFromRange(raw, cea608Ranges[j]);\n                for (let k = 0; k < 2; k++) {\n                    if (ccData[k].length > 0) {\n                        if (sample.cts !== lastSampleTime) {\n                            idx = 0;\n                        } else {\n                            idx += 1;\n                        }\n                        allCcData.fields[k].push([sample.cts + (mseTimeOffset * embeddedTimescale), ccData[k], idx]);\n                        lastSampleTime = sample.cts;\n                    }\n                }\n            }\n        }\n\n        // Sort by sampleTime ascending order\n        // If two packets have the same sampleTime, use them in the order\n        // they were received\n        allCcData.fields.forEach(function sortField(field) {\n            field.sort(function (a, b) {\n                if (a[0] === b[0]) {\n                    return a[2] - b[2];\n                }\n                return a[0] - b[0];\n            });\n        });\n\n        return allCcData;\n    }\n\n    function getIsDefault(mediaInfo) {\n        //TODO How to tag default. currently same order as listed in manifest.\n        // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND\n        // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet.\n        let isDefault = false;\n        if (embeddedTracks.length > 1 && mediaInfo.isEmbedded) {\n            isDefault = (mediaInfo.id && mediaInfo.id === Constants.CC1); // CC1 if both CC1 and CC3 exist\n        } else if (embeddedTracks.length === 1) {\n            if (mediaInfo.id && typeof mediaInfo.id === 'string' && mediaInfo.id.substring(0, 2) === 'CC') { // Either CC1 or CC3\n                isDefault = true;\n            }\n        } else if (embeddedTracks.length === 0) {\n            isDefault = (mediaInfo.index === mediaInfos[0].index);\n        }\n        return isDefault;\n    }\n\n    function getParser(codecType) {\n        let parser;\n        if (codecType.search(Constants.VTT) >= 0) {\n            parser = vttParser;\n        } else if (codecType.search(Constants.TTML) >= 0 || codecType.search(Constants.STPP) >= 0) {\n            parser = ttmlParser;\n        }\n        return parser;\n    }\n\n    function remove(start, end) {\n        //if start and end are not defined, remove all\n        if ((start === undefined) && (start === end)) {\n            start = this.buffered.start(0);\n            end = this.buffered.end(this.buffered.length - 1);\n        }\n        this.buffered.remove(start, end);\n    }\n\n    instance = {\n        initialize: initialize,\n        append: append,\n        abort: abort,\n        addEmbeddedTrack: addEmbeddedTrack,\n        resetEmbedded: resetEmbedded,\n        setConfig: setConfig,\n        getConfig: getConfig,\n        setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx,\n        remove: remove,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer';\nexport default FactoryMaker.getSingletonFactory(TextSourceBuffer);\n"]}