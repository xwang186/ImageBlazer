{"version":3,"sources":["../../../../src/streaming/SourceBufferSink.js"],"names":[],"mappings":"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","file":"SourceBufferSink.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport DashJSError from './vo/DashJSError';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport TextController from './text/TextController';\nimport Errors from '../core/errors/Errors';\n\nconst MAX_ALLOWED_DISCONTINUITY = 0.1; // 100 milliseconds\n\n/**\n * @class SourceBufferSink\n * @implements FragmentSink\n */\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        buffer,\n        isAppendingInProgress,\n        intervalId;\n\n    let callbacks = [];\n    let appendQueue = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        isAppendingInProgress = false;\n\n        const codec = mediaInfo.codec;\n        try {\n            // Safari claims to support anything starting 'application/mp4'.\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n            // - currently no browser does, so check for it and use our own\n            // implementation. The same is true for codecs=\"wvtt\".\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n                throw new Error('not really supported');\n            }\n            buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\n            if (buffer.changeType && oldBuffer) {\n                logger.debug('Doing period transition with changeType');\n                buffer.changeType(codec);\n            }\n\n            const CHECK_INTERVAL = 50;\n            // use updateend event if possible\n            if (typeof buffer.addEventListener === 'function') {\n                try {\n                    buffer.addEventListener('updateend', updateEndHandler, false);\n                    buffer.addEventListener('error', errHandler, false);\n                    buffer.addEventListener('abort', errHandler, false);\n\n                } catch (err) {\n                    // use setInterval to periodically check if updating has been completed\n                    intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n                }\n            } else {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } catch (ex) {\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\n                const textController = TextController(context).getInstance();\n                buffer = textController.getTextSourceBuffer();\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    function reset(keepBuffer) {\n        if (buffer) {\n            if (typeof buffer.removeEventListener === 'function') {\n                buffer.removeEventListener('updateend', updateEndHandler, false);\n                buffer.removeEventListener('error', errHandler, false);\n                buffer.removeEventListener('abort', errHandler, false);\n            }\n            clearInterval(intervalId);\n            if (!keepBuffer) {\n                try {\n                    if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\n                        mediaSource.removeSourceBuffer(buffer);\n                    }\n                } catch (e) {\n                    logger.error('Failed to remove source buffer from media source.');\n                }\n                buffer = null;\n            }\n            isAppendingInProgress = false;\n        }\n        appendQueue = [];\n        onAppended = null;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function getAllBufferRanges() {\n        try {\n            return buffer.buffered;\n        } catch (e) {\n            logger.error('getAllBufferRanges exception: ' + e.message);\n            return null;\n        }\n    }\n\n    function hasDiscontinuitiesAfter(time) {\n        try {\n            const ranges = getAllBufferRanges();\n            if (ranges && ranges.length > 1) {\n                for (let i = 0, len = ranges.length; i < len; i++) {\n                    if (i > 0) {\n                        if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            logger.error('hasDiscontinuities exception: ' + e.message);\n        }\n        return false;\n    }\n\n    function append(chunk) {\n        if (!chunk) {\n            onAppended({\n                chunk: chunk,\n                error: new DashJSError(Errors.APPEND_ERROR_CODE, Errors.APPEND_ERROR_MESSAGE)\n            });\n            return;\n        }\n        appendQueue.push(chunk);\n        if (!isAppendingInProgress) {\n            waitForUpdateEnd(buffer, appendNextInQueue.bind(this));\n        }\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            waitForUpdateEnd(buffer, () => {\n                buffer.timestampOffset = MSETimeOffset;\n            });\n        }\n    }\n\n    function remove(start, end, forceRemoval) {\n        const sourceBufferSink = this;\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n        waitForUpdateEnd(buffer, function () {\n            try {\n                if ((start >= 0) && (end > start) && (forceRemoval || mediaSource.readyState !== 'ended')) {\n                    buffer.remove(start, end);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(buffer, function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                        buffer: sourceBufferSink,\n                        from: start,\n                        to: end,\n                        unintended: false\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                    buffer: sourceBufferSink,\n                    from: start,\n                    to: end,\n                    unintended: false,\n                    error: new DashJSError(err.code, err.message)\n                });\n            }\n        });\n    }\n\n    function appendNextInQueue() {\n        const sourceBufferSink = this;\n\n        if (appendQueue.length > 0) {\n            isAppendingInProgress = true;\n            const nextChunk = appendQueue[0];\n            appendQueue.splice(0,1);\n            let oldRanges = [];\n            const afterSuccess = function () {\n                // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\n                const newRanges = getAllBufferRanges();\n                checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\n                if (appendQueue.length > 0) {\n                    appendNextInQueue.call(this);\n                } else {\n                    isAppendingInProgress = false;\n                    if (onAppended) {\n                        onAppended({\n                            chunk: nextChunk\n                        });\n                    }\n                }\n            };\n\n            try {\n                if (nextChunk.bytes.length === 0) {\n                    afterSuccess.call(this);\n                } else {\n                    oldRanges = getAllBufferRanges();\n                    if (buffer.appendBuffer) {\n                        buffer.appendBuffer(nextChunk.bytes);\n                    } else {\n                        buffer.append(nextChunk.bytes, nextChunk);\n                    }\n                    // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                    waitForUpdateEnd(buffer, afterSuccess.bind(this));\n                }\n            } catch (err) {\n                logger.fatal('SourceBuffer append failed \"' + err + '\"');\n                if (appendQueue.length > 0) {\n                    appendNextInQueue();\n                } else {\n                    isAppendingInProgress = false;\n                }\n\n                if (onAppended) {\n                    onAppended({\n                        chunk: nextChunk,\n                        error: new DashJSError(err.code, err.message)\n                    });\n                }\n            }\n        }\n    }\n\n    function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\n        if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length &&\n            isChunkAlignedWithRange(oldRanges, chunk)) {\n            // A split in the range was created while appending\n            eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                buffer: buffer,\n                from: newRanges.end(newRanges.length - 2),\n                to: newRanges.start(newRanges.length - 1),\n                unintended: true\n            });\n        }\n    }\n\n    function isChunkAlignedWithRange(oldRanges, chunk) {\n        for (let i = 0; i < oldRanges.length; i++ ) {\n            const start = Math.round(oldRanges.start(i));\n            const end = Math.round(oldRanges.end(i));\n            if (end === chunk.start || start === chunk.end || (chunk.start >= start && chunk.end <= end) ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function abort() {\n        try {\n            if (mediaSource.readyState === 'open') {\n                buffer.abort();\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n            }\n        } catch (ex) {\n            logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\n        }\n        appendQueue = [];\n    }\n\n    function executeCallback() {\n        if (callbacks.length > 0) {\n            const cb = callbacks.shift();\n            if (buffer.updating) {\n                waitForUpdateEnd(buffer, cb);\n            } else {\n                cb();\n                // Try to execute next callback if still not updating\n                executeCallback();\n            }\n        }\n    }\n\n    function checkIsUpdateEnded() {\n        // if updating is still in progress do nothing and wait for the next check again.\n        if (buffer.updating) return;\n        // updating is completed, now we can stop checking and resolve the promise\n        executeCallback();\n    }\n\n    function updateEndHandler() {\n        if (buffer.updating) return;\n\n        executeCallback();\n    }\n\n    function errHandler() {\n        logger.error('SourceBufferSink error', mediaInfo.type);\n    }\n\n    function waitForUpdateEnd(buffer, callback) {\n        callbacks.push(callback);\n\n        if (!buffer.updating) {\n            executeCallback();\n        }\n    }\n\n    instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        getBuffer: getBuffer,\n        append: append,\n        remove: remove,\n        abort: abort,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter\n    };\n\n    setup();\n\n    return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\nconst factory = FactoryMaker.getClassFactory(SourceBufferSink);\nexport default factory;\n"]}